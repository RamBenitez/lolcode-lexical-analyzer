# parser/parser.py

#syntacx analyzer parser for the lolcode
# it takes a list of tokens generated by the lexical analyzer (tokenizer) and
#constructs a parse tree (or AST) representing the program's structure.


from .node import Node
from .symbol_table import SymbolTable

class Parser:
    #Initializes the parse using the tokens
    def __init__(self, tokens):
        self.tokens = tokens
        self.position = 0
        self.symbol_table = SymbolTable()

    #get the current token
    def current_token(self):
        if self.position < len(self.tokens):
            return self.tokens[self.position]
        return None

    # advance to the next token
    def advance(self):
        self.position += 1
    
    # match the current token with expected type and value
    def match(self, expected_type, expected_value=None):
        token = self.current_token()
        if token['type'] == expected_type:
            if expected_value is None or token['value'] == expected_value:
                self.advance()
                return token
        err_msg = f"Syntax Error: Expected  '{expected_type}'"
        raise SyntaxError(err_msg)

    #parse the token and creates the AST
    def parse(self):
        return self.parse_program()
    
    # parses the program
    def parse_program(self):
        program_node = Node('program')
        self.match('HAI')
        self.match('LINEBREAK')
        if self.current_token() and self.current_token()['type'] == 'WAZZUP':
            program_node.add_child(self.parse_variable_declaration_block())
        while self.current_token() and self.current_token()['type'] != 'KTHXBYE':
            program_node.add_child(self.parse_statement())
            self.match('LINEBREAK')
        self.match('KTHXBYE')
        return program_node

    # parses variable declarations
    def parse_variable_declaration_block(self):
        block_node = Node('variable_declaration_block')
        self.match('WAZZUP')
        self.match('LINEBREAK')
        while self.current_token() and self.current_token()['type'] != 'BUHBYE':
            if self.current_token()['type'] == 'I HAS A':
                 block_node.add_child(self.parse_variable_declaration())
                 self.match('LINEBREAK')
        self.match('BUHBYE')
        self.match('LINEBREAK')
        return block_node

    def parse_statement(self):
        token_type = self.current_token()['type']
        if token_type == 'VISIBLE':
            return self.parse_print_statement()
        elif token_type == 'IDENTIFIER':
            return self.parse_assignment()

    def parse_variable_declaration(self):
        self.match('I HAS A')
        var_name_token = self.match('IDENTIFIER')
        var_name = var_name_token['value']
        node = Node('variable_declaration', value=var_name)
        initial_value = None
        if self.current_token() and self.current_token()['type'] == 'ITZ':
            self.match('ITZ')
            expr_node = self.parse_expression()
            node.add_child(expr_node)
            initial_value = expr_node
        self.symbol_table.declare(var_name, initial_value)
        return node

    def parse_assignment(self):
        var_name_token = self.match('IDENTIFIER')
        var_name = var_name_token['value']
        self.symbol_table.lookup(var_name)
        node = Node('assignment', value=var_name)
        self.match('R')
        expr_node = self.parse_expression()
        node.add_child(expr_node)
        self.symbol_table.update(var_name, expr_node)
        return node

    def parse_print_statement(self):
        self.match('VISIBLE')
        node = Node('print_statement')
        expr_node = self.parse_expression()
        node.add_child(expr_node)
        return node
        
    def parse_expression(self):
        token = self.current_token()
        operation_types = ['SUM OF', 'DIFF OF', 'PRODUKT OF', 'QUOSHUNT OF', 'MOD OF', 'BIGGR OF', 'SMALLR OF', 'BOTH SAEM', 'DIFFRINT']
        if token['type'] in operation_types:
            return self.parse_binary_operation()
        elif 'Literal' in token['type']:
            return self.parse_literal()
        elif token['type'] == 'IDENTIFIER':
            self.symbol_table.lookup(token['value'])
            return Node('variable', value=self.match('IDENTIFIER')['value'])

    def parse_literal(self):
        token = self.current_token()
        if token['type'] == 'NUMBR Literal':
            return Node('literal_numbr', value=int(self.match('NUMBR Literal')['value']))
        elif token['type'] == 'NUMBAR Literal':
            return Node('literal_numbar', value=float(self.match('NUMBAR Literal')['value']))
        elif token['type'] == 'YARN Literal':
            yarn_value = self.match('YARN Literal')['value']
            return Node('literal_yarn', value=yarn_value[1:-1])
        elif token['type'] == 'TROOF Literal':
            return Node('literal_troof', value=self.match('TROOF Literal')['value'])

    def parse_binary_operation(self):
        op_token = self.current_token()
        self.advance()
        node = Node('binary_operation', value=op_token['type'])
        left_expr = self.parse_expression()
        node.add_child(left_expr)
        self.match('AN')
        right_expr = self.parse_expression()
        node.add_child(right_expr)
        return node