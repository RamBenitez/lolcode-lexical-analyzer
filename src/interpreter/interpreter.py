# interpreter/interpreter.py
# Executes the AST generated by the parser

class Interpreter:
    """Executes LOLCode AST and manages runtime state"""
    
    def __init__(self, ast, symbol_table):
        self.ast = ast
        self.symbol_table = symbol_table
        self.output = []  # Store VISIBLE output
        self.input_buffer = []  # For GIMMEH (can be pre-filled for testing)
        
        # Create the implicit IT variable
        if "IT" not in self.symbol_table.symbols:
            self.symbol_table.symbols["IT"] = None
    
    def execute(self):
        """Execute the entire program"""
        if self.ast.type != 'program':
            raise RuntimeError("AST root must be a program node")
        
        # Execute all statements in the program
        for child in self.ast.children:
            self.execute_node(child)
        
        return self.output
    
    def execute_node(self, node):
        """Execute a single AST node"""
        if node is None:
            return None
        
        node_type = node.type
        
        # Variable declaration block
        if node_type == 'variable_declaration_block':
            for child in node.children:
                self.execute_node(child)
            return None
        
        # Variable declaration (I HAS A)
        elif node_type == 'variable_declaration':
            var_name = node.value
            if node.children:
                # Has initialization (ITZ)
                initial_value = self.evaluate_expression(node.children[0])
                self.symbol_table.symbols[var_name] = initial_value
            else:
                # No initialization - set to NOOB
                self.symbol_table.symbols[var_name] = None
            return None
        
        # Assignment statement (R)
        elif node_type == 'assignment':
            var_name = node.value
            new_value = self.evaluate_expression(node.children[0])
            self.symbol_table.symbols[var_name] = new_value
            return None
        
        # Print statement (VISIBLE)
        elif node_type == 'print_statement':
            output_parts = []
            for child in node.children:
                value = self.evaluate_expression(child)
                # Convert to string for output
                output_parts.append(self.to_yarn(value))
            output_line = "".join(output_parts)
            self.output.append(output_line)
            # Store result in IT
            self.symbol_table.symbols["IT"] = output_line
            return None
        
        else:
            # For other node types, try to evaluate as expression
            return self.evaluate_expression(node)
    
    def evaluate_expression(self, node):
        """Evaluate an expression and return its value"""
        if node is None:
            return None
        
        node_type = node.type
        
        # Literals
        if node_type == 'literal_numbr':
            return int(node.value)
        
        elif node_type == 'literal_numbar':
            return float(node.value)
        
        elif node_type == 'literal_yarn':
            return str(node.value)
        
        elif node_type == 'literal_troof':
            return node.value == 'WIN'
        
        # Variable reference
        elif node_type == 'variable':
            var_name = node.value
            if var_name not in self.symbol_table.symbols:
                raise RuntimeError(f"Variable '{var_name}' not declared")
            value = self.symbol_table.symbols[var_name]
            # Store in IT
            self.symbol_table.symbols["IT"] = value
            return value
        
        # Binary operations
        elif node_type == 'binary_operation':
            operation = node.value
            left = self.evaluate_expression(node.children[0])
            right = self.evaluate_expression(node.children[1])
            result = self.execute_binary_operation(operation, left, right)
            # Store result in IT
            self.symbol_table.symbols["IT"] = result
            return result
        
        else:
            raise RuntimeError(f"Unknown expression type: {node_type}")
    
    def execute_binary_operation(self, operation, left, right):
        """Execute a binary operation"""
        
        # Arithmetic operations
        if operation == 'SUM OF':
            left_num = self.to_number(left)
            right_num = self.to_number(right)
            result = left_num + right_num
            # Return NUMBAR if either operand is NUMBAR, else NUMBR
            return result if isinstance(left_num, float) or isinstance(right_num, float) else int(result)
        
        elif operation == 'DIFF OF':
            left_num = self.to_number(left)
            right_num = self.to_number(right)
            result = left_num - right_num
            return result if isinstance(left_num, float) or isinstance(right_num, float) else int(result)
        
        elif operation == 'PRODUKT OF':
            left_num = self.to_number(left)
            right_num = self.to_number(right)
            result = left_num * right_num
            return result if isinstance(left_num, float) or isinstance(right_num, float) else int(result)
        
        elif operation == 'QUOSHUNT OF':
            left_num = self.to_number(left)
            right_num = self.to_number(right)
            if right_num == 0:
                raise RuntimeError("Division by zero")
            result = left_num / right_num
            return result if isinstance(left_num, float) or isinstance(right_num, float) else int(result)
        
        elif operation == 'MOD OF':
            left_num = self.to_number(left)
            right_num = self.to_number(right)
            if right_num == 0:
                raise RuntimeError("Modulo by zero")
            result = left_num % right_num
            return result if isinstance(left_num, float) or isinstance(right_num, float) else int(result)
        
        elif operation == 'BIGGR OF':
            left_num = self.to_number(left)
            right_num = self.to_number(right)
            result = max(left_num, right_num)
            return result if isinstance(left_num, float) or isinstance(right_num, float) else int(result)
        
        elif operation == 'SMALLR OF':
            left_num = self.to_number(left)
            right_num = self.to_number(right)
            result = min(left_num, right_num)
            return result if isinstance(left_num, float) or isinstance(right_num, float) else int(result)
        
        # Comparison operations
        elif operation == 'BOTH SAEM':
            return left == right
        
        elif operation == 'DIFFRINT':
            return left != right
        
        # Boolean operations
        elif operation == 'BOTH OF':
            return self.to_troof(left) and self.to_troof(right)
        
        elif operation == 'EITHER OF':
            return self.to_troof(left) or self.to_troof(right)
        
        elif operation == 'WON OF':
            return self.to_troof(left) != self.to_troof(right)
        
        else:
            raise RuntimeError(f"Unknown operation: {operation}")
    
    # Type conversion helpers
    def to_number(self, value):
        """Convert value to NUMBR or NUMBAR"""
        if value is None:
            raise RuntimeError("Cannot convert NOOB to number")
        
        if isinstance(value, bool):
            return 1 if value else 0
        
        if isinstance(value, int):
            return value
        
        if isinstance(value, float):
            return value
        
        if isinstance(value, str):
            # Try to convert string to number
            try:
                if '.' in value:
                    return float(value)
                else:
                    return int(value)
            except ValueError:
                raise RuntimeError(f"Cannot convert '{value}' to number")
        
        raise RuntimeError(f"Cannot convert {type(value)} to number")
    
    def to_yarn(self, value):
        """Convert value to YARN (string)"""
        if value is None:
            return ""
        
        if isinstance(value, bool):
            return "WIN" if value else "FAIL"
        
        if isinstance(value, float):
            # Truncate to 2 decimal places
            return f"{value:.2f}"
        
        return str(value)
    
    def to_troof(self, value):
        """Convert value to TROOF (boolean)"""
        if value is None:
            return False
        
        if isinstance(value, bool):
            return value
        
        if isinstance(value, (int, float)):
            return value != 0
        
        if isinstance(value, str):
            return value != ""
        
        return True
